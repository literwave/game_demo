# 框架性能分析报告

## 📊 架构概览

### 当前配置
- **工作线程数**: 8
- **最大在线人数**: 2000 (配置限制)
- **Agent 初始数量**: 2
- **单个 Agent 最大用户数**: 500
- **登录 Slave 数量**: 3
- **网关**: 单点部署

### 服务架构
```
Client → Gate (单点) → Agent Pool (2个) → MongoDB
         ↓
      Logind (Master + 3 Slaves)
```

## 🔍 性能瓶颈分析

### 1. **Agent 消息处理瓶颈** ⚠️ 严重

**问题代码** (`logic/service/agent/agent.lua:46`):
```lua
local q = queue()  -- 串行队列
skynet.dispatch("client", function(fd, addr, packMsg, sz)
    -- ...
    pcall(q, for_maker[ptoName], fd, msg)  -- 所有消息串行处理
end)
```

**影响**:
- ❌ **所有玩家消息串行处理**，一个慢操作会阻塞所有玩家
- ❌ 无法充分利用多核 CPU
- ❌ 高并发下延迟会急剧上升

**理论性能**:
- 假设每个消息处理耗时 1ms
- 单 Agent 500 用户，每秒 10 条消息/用户
- 需要处理: 500 × 10 = 5000 消息/秒
- 串行处理能力: 1000 消息/秒
- **结论**: 严重不足，延迟会累积到秒级

### 2. **Gate 单点瓶颈** ⚠️ 中等

**问题**:
- Gate 服务是单点，所有连接都经过它
- 没有负载均衡机制
- 单点故障影响所有用户

**影响**:
- 连接数受限于单机 TCP 连接上限（通常 65535）
- 消息转发成为瓶颈
- 无法水平扩展

### 3. **Agent 数量不足** ⚠️ 中等

**当前配置**:
- `agent_init_cnt = 2`
- `agent_max_user_cnt = 500`
- **理论最大**: 2 × 500 = 1000 用户

**问题**:
- 配置的 `maxonline = 2000`，但 Agent 只能支持 1000
- Agent 不会自动扩容
- 负载不均衡（简单的轮询分配）

### 4. **内存使用** ✅ 良好

**用户数据存储** (`logic/module/user/mgr.lua`):
```lua
allUserTbl = {}  -- [userId] = userObj
```

**优点**:
- 内存访问速度快
- 数据结构简单高效
- 适合热数据缓存

**潜在问题**:
- 用户数据全部常驻内存
- 500 用户/Agent × 2 Agent = 1000 用户
- 假设每个用户对象 10KB，约 10MB（可接受）

### 5. **数据库访问** ⚠️ 中等

**问题**:
- MongoDB 操作是同步的（`skynet.call`）
- 登录时可能触发数据库查询
- 没有连接池管理

**影响**:
- 数据库慢查询会阻塞服务
- 高并发下数据库成为瓶颈

## 📈 性能估算

### 理论最大并发

**基于当前配置**:
```
Agent 数量: 2
单 Agent 用户数: 500
理论最大: 2 × 500 = 1000 用户
```

**实际支持能力** (考虑瓶颈):

| 场景 | 支持人数 | 说明 |
|------|---------|------|
| **轻负载** (1 msg/s/用户) | **800-1000** | 消息少，延迟可接受 |
| **中等负载** (5 msg/s/用户) | **400-600** | 延迟开始上升 |
| **重负载** (10 msg/s/用户) | **200-300** | 延迟严重，体验差 |
| **峰值** (20 msg/s/用户) | **100-150** | 接近崩溃 |

### 延迟分析

**消息处理延迟** (串行队列):
- 空载: < 1ms
- 500 用户，5 msg/s: ~2.5ms (500 × 5 / 1000)
- 500 用户，10 msg/s: ~5ms
- 500 用户，20 msg/s: ~10ms (延迟累积)

**实际用户体验**:
- 延迟 < 50ms: 流畅 ✅
- 延迟 50-200ms: 可接受 ⚠️
- 延迟 > 200ms: 卡顿 ❌

## 🎯 优化建议

### 1. **移除串行队列** 🔥 关键

**当前问题**:
```lua
local q = queue()  -- 串行处理
pcall(q, for_maker[ptoName], fd, msg)
```

**优化方案**:
```lua
-- 方案 A: 按用户 ID 分片队列
local userQueues = {}  -- [userId % N] = queue()
local function getUserQueue(userId)
    local idx = (userId or 0) % 10  -- 10 个队列
    if not userQueues[idx] then
        userQueues[idx] = queue()
    end
    return userQueues[idx]
end

-- 方案 B: 完全并发（需要保证线程安全）
for_maker[ptoName](fd, msg)  -- 直接调用，不排队
```

**预期提升**: 性能提升 **5-10 倍**

### 2. **增加 Agent 数量**

**当前**: `agent_init_cnt = 2`

**建议**:
```lua
agent_init_cnt = 10  -- 根据实际需求调整
agent_max_user_cnt = 500  -- 保持不变
```

**预期**: 支持 **5000 用户** (10 × 500)

### 3. **Gate 负载均衡**

**方案**: 多 Gate 实例 + 负载均衡器
```
Client → Load Balancer → Gate1, Gate2, Gate3...
```

**或使用 Skynet 的 Harbor 模式**:
```lua
harbor = 1  -- 启用多节点
```

### 4. **数据库优化**

**方案 A: 异步化**
```lua
-- 使用 skynet.send 异步调用
skynet.send(".mongodb", "lua", "update", args)
```

**方案 B: 连接池**
- 实现 MongoDB 连接池
- 批量操作减少网络往返

**方案 C: 缓存策略**
- 热数据常驻内存
- 冷数据延迟加载
- 定期批量保存

### 5. **消息批处理**

**当前**: 逐条处理消息

**优化**: 批量处理
```lua
local messageBatch = {}
skynet.dispatch("client", function(fd, addr, packMsg, sz)
    table.insert(messageBatch, {fd, packMsg, sz})
    if #messageBatch >= 100 then
        processBatch(messageBatch)
        messageBatch = {}
    end
end)
```

## 📊 优化后性能预估

### 优化方案组合

| 优化项 | 提升倍数 | 说明 |
|--------|---------|------|
| 移除串行队列 | 5-10x | 并发处理消息 |
| 增加 Agent 到 10 | 5x | 更多处理能力 |
| Gate 负载均衡 | 3-5x | 分散连接压力 |
| 数据库优化 | 2-3x | 减少阻塞 |

### 优化后支持能力

**保守估计** (应用部分优化):
- **轻负载**: 3000-5000 用户
- **中等负载**: 1500-2500 用户
- **重负载**: 800-1200 用户

**激进估计** (全部优化):
- **轻负载**: 10000+ 用户
- **中等负载**: 5000-8000 用户
- **重负载**: 2000-4000 用户

## 🎮 实际测试建议

### 压测工具
```bash
# 使用工具模拟客户端
# 1. 连接数测试
# 2. 消息频率测试
# 3. 延迟测试
```

### 监控指标
- CPU 使用率
- 内存使用
- 消息处理延迟
- 数据库响应时间
- 网络 I/O

### 测试场景
1. **连接测试**: 逐步增加连接数，观察性能
2. **消息频率**: 不同消息频率下的延迟
3. **峰值测试**: 突发流量下的表现
4. **长时间运行**: 内存泄漏、性能衰减

## 📝 总结

### 当前框架评估

**优点** ✅:
- 架构清晰，易于理解
- 使用 Skynet 高性能框架
- 模块化设计，易于扩展
- 内存缓存策略合理

**缺点** ❌:
- Agent 串行队列是严重瓶颈
- Agent 数量配置不足
- Gate 单点，无法水平扩展
- 数据库操作可能阻塞

### 当前支持能力

**实际支持**: **500-1000 用户** (轻到中等负载)

**配置限制**: 2000 用户 (但实际无法达到)

### 优化优先级

1. **🔥 紧急**: 移除 Agent 串行队列
2. **⚠️ 重要**: 增加 Agent 数量
3. **⚠️ 重要**: Gate 负载均衡
4. **📌 建议**: 数据库异步化
5. **📌 建议**: 消息批处理

### 最终建议

**短期** (1-2周):
- 移除串行队列，改为并发处理
- 增加 Agent 数量到 10
- **预期**: 支持 3000-5000 用户

**中期** (1-2月):
- 实现 Gate 负载均衡
- 优化数据库访问
- **预期**: 支持 5000-10000 用户

**长期** (3-6月):
- 实现自动扩容
- 完善监控和告警
- 性能调优和压力测试
- **预期**: 支持 10000+ 用户

---

**结论**: 当前框架在**轻负载场景下可支持 500-1000 用户**，但存在明显的性能瓶颈。通过优化，**可提升到 5000-10000+ 用户**的并发能力。

